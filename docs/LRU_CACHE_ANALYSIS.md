# LRU Cache Type Inference Analysis

## 问题描述

用户报告 `examples/lru-cache.js` 在类型推断时出现错误：
```
Property 'next' is missing
at line 27, column 2
```

## 根本原因分析

经过深入分析，发现了**两个独立的问题**：

### 1. 成员访问缺乏记忆化（Memoization）【已修复 ✅】

**问题**：
- 每次访问同一个属性（如 `this.head.next`）都会创建**新的类型变量**
- 导致多次访问无法共享同一个类型，约束无法正确传播

**示例**：
```javascript
this.head.next = this.tail;       // 第一次访问 head.next -> 创建 TypeVar₁
this.head.next.prev = node;       // 第二次访问 head.next -> 创建 TypeVar₂
```

TypeVar₁ 和 TypeVar₂ 是不同的变量，所以约束无法传播！

**解决方案**：
在 `InferenceContext` 中添加了基于路径的成员访问缓存：

```typescript
// src/inferrer/context.ts
private memberCache: Map<string, Map<string, TypeVar>>;

getCachedMemberVar(objectPath: string, propertyName: string): TypeVar {
  // 为同一路径的属性返回相同的 TypeVar
}

getStablePath(expr: any): string | null {
  // 从表达式构建稳定的路径字符串
  // 例如：this.head -> "this.head"
  //      obj.prop -> "obj.prop"
}
```

在 `inferMemberExpression` 中使用缓存：
```typescript
const objectPath = ctx.getStablePath(expr.object);
const propVar = objectPath
  ? ctx.getCachedMemberVar(objectPath, propName)  // 使用缓存
  : ctx.fresh(propName);                           // 对复杂表达式不缓存
```

**测试结果**：
```
✓ 简单字段更新（this.obj.a = 10）
✓ 嵌套字段更新（this.outer.inner.value = 100）
✓ 多次访问同一字段
```

### 2. 循环引用结构（Circular References）【已知限制 ⚠️】

**问题**：
LRU cache 使用了循环引用的双向链表：

```javascript
function LRUCache() {
  this.head = { ..., prev: null, next: null };
  this.tail = { ..., prev: null, next: null };
  this.head.next = this.tail;    // head.next 指向 tail
  this.tail.prev = this.head;    // tail.prev 指向 head (循环!)
}
```

初始时：
- `head.prev: null`
- `head.next: null`

赋值后：
- `head.next: { key, value, prev, next }` (指向 tail)
- `tail.prev: { key, value, prev, next }` (指向 head)

这形成了**自引用结构** (self-referential structure)，需要 **recursive types**：

```typescript
type Node = {
  key: any,
  value: any,
  prev: Node | null,
  next: Node | null
}
```

**当前限制**：
MLsub 的类型推断系统**不会自动生成 recursive types**。虽然类型系统支持 `RecursiveType`（μα.τ），但推断算法不会为循环引用自动创建它们。

**当前错误**：
```
Type 'primitive' is not assignable to type 'record'
at line 12, column 2
```

这是因为 `null`（primitive）无法与 record 类型统一。

**可能的解决方案**：
1. **自动检测循环引用并生成 recursive types**（需要大量工作）
2. **允许用户手动标注 recursive types**（通过 JSDoc 或 TypeScript 注解）
3. **接受限制**：某些复杂的自引用结构无法自动推断

## 影响评估

### 修复前 vs 修复后

**修复前**（无成员访问缓存）：
```
Property 'next' is missing
at line 27, column 2
```
- 错误出现在 `addToFront` 方法（line 27）
- 完全无法推断 LRU cache

**修复后**（有成员访问缓存）：
```
Type 'primitive' is not assignable to type 'record'
at line 12, column 2
```
- 错误提前到构造函数（line 12）
- **准确定位到循环引用问题**
- 简单场景（无循环引用）工作正常 ✅

### 我们的 Record Lattice 实现

✅ **与此错误无关！**

- LRU cache 错误在迁移到 MLsub lattice **之前就存在**
- 通过 git 历史验证：`git checkout ecc7ad5` 仍然有相同错误
- Record join/meet 实现正确，所有测试通过

## 测试结果

### Record Lattice 测试（✅ 全部通过）
```
✓ Record Join (⊔) - Domain Intersection (4 tests)
✓ Record Meet (⊓) - Domain Union (4 tests)
✓ Width Subtyping via Lattice (1 test)
```

### Member Cache 测试（✅ 基本通过）
```
✓ Test 1: 简单字段更新
✓ Test 2: 嵌套成员更新
⚠ Test 3: Prototype methods（另一个已知问题）
```

### 整体测试套件
```
Test Files  2 passed | 1 skipped (3)
Tests      29 passed | 1 skipped (30)
```

## 结论

### 已完成 ✅

1. **移除 row variables，完全采用 MLsub lattice 方案**
   - Record join (⊔)：domain 取交集
   - Record meet (⊓)：domain 取并集
   - Width/depth subtyping 自动支持

2. **优雅修复成员访问缓存问题**
   - 添加基于路径的 TypeVar 缓存
   - 解决多次访问同一属性的问题
   - 对简单场景有效

### 已知限制 ⚠️

1. **循环引用结构**
   - 需要 recursive types，但推断算法不自动生成
   - 影响：双向链表、图结构等自引用数据结构
   - 建议：对这类结构提供手动类型标注

2. **Prototype chain 推断**
   - 影响：某些 prototype-based 模式
   - 这是另一个独立问题

## 建议

对于 LRU cache 这样的例子：

1. **短期**：添加注释说明这是已知限制
2. **中期**：支持 JSDoc 类型标注来辅助推断
3. **长期**：实现循环引用检测和 recursive type 生成

---

*Generated by Typeripper Analysis Team*
*Date: 2026-01-09*
